# -*- coding: utf-8 -*-
"""
Created on Mon Mar 30 16:58:35 2015

@author: Yan
"""

import numpy as np

repers = open('repers_endless.txt', 'w')                     #создание файла
repers.close()

phi0 = [0,  1.36,  -0.49, 0.36]                              #параметры авторегрессионных моделей
phi1 = [0,  1.02,  -0.40, 0.63]                              #последнее число - параметр B, определяющий
phi2 = [0,  0.82,  -0.49, 0.73]                              #                      степень влияния шума
phi3 = [0,  0,     -0.49, 0.87]
phi4 = [0, -0.82,  -0.49, 0.73]
phi = np.array([phi0,phi1,phi2,phi3,phi4])
n = 2                                                        #порядок авторегрессии
m = 5                                                        #количество различных классов{моделей}

q1 = [0.99,   0.0025, 0.0025, 0.0025, 0.0025]
q2 = [0.0025, 0.99,   0.0025, 0.0025, 0.0025]
q3 = [0.0025, 0.0025, 0.99,   0.0025, 0.0025]
q4 = [0.0025, 0.0025, 0.0025, 0.99,   0.0025]
q5 = [0.0025, 0.0025, 0.0025, 0.0025, 0.99]
Q = np.array([q1,q2,q3,q4,q5])                              #матрица вер-ти переходов

curr_t = -1                                                 #текущий номер
x = []                                                      #список для хранения отсчетов

##########################################################################################
############################Блок генератора модельных данных##############################
##########################################################################################

while(curr_t != n-1 ):                                      #начальное наполнение случайными данными
    x.append(np.random.randn())                             #т.к. AR(n) основывается на n пред.значениях
    curr_t += 1
    
N_start = curr_t + 1                                        #номер, с которого начнутся модельные данные
h_start = 0                                                 #начальный выбор модели

def generate_number(h_curr):                                #функция генератора
    repers = open('repers_endless.txt', 'a')                #файл точек, где происходит смена модели
    #для смены модели пропорционально вероятности, я решил брать рандомное число, принадлежащее [0,1],
    #разбить этот отрезок на сегменты, равные, собственно, вероятностям и смотреть, в какой сегмент
    #случайное число попало                                          
    factor = np.random.random()
    p_curr = 0
    global curr_t                                           #работаем с глобальным счетчиком отсчетов
    curr_t += 1
    for h_next in range(0,m):
        p_curr += Q[h_curr][h_next]
        if(p_curr >= factor):
            if(h_curr != h_next):
                print('Model change: N', curr_t, h_curr, '-->', h_next)
                repers.write(str(curr_t) + ' ' + str(h_curr) + '\n')        #конец предыдущего сегмента
                repers.write(str(curr_t) + ' ' + str(h_next) + '\n')        #начало следующего
                h_curr = h_next
            break
    #цикл формирования отсчета AR(n)-процесса
    x_curr = phi[h_curr][0]
    for i in range(1,n+1):
        x_curr += phi[h_curr][i]*x[curr_t - i]
    x_curr += phi[h_curr][3]*np.random.randn()              #шум    
    #заменил random.random() на random.randn() - он имеет нормальное распределение, почему-то стало
                                                                                             #лучше
    x.append(x_curr)
    print(x_curr,'h_curr =',h_curr)
    repers.close()
    return h_curr                                           #возвращаем текущую модель
    
##########################################################################################
############################Блок анализатора данных#######################################
##########################################################################################

def beta(t, h_t1, h_t):                                     #ф-ция beta
    summ = 0                                                #сначала надо посчитать сумму, зав. от x
    for i in range(1,n+1):                                            
        summ += x[t-i]*phi[h_t][i]
    res = (1/(2*phi[h_t][3]))*(x[t] - phi[h_t][0] - summ)**2 - np.log(Q[h_t1][h_t]) #по формуле из статьи
    return res

def d_t(d_t1):                                              #рекуррентный расчет d_t
    res = []
    k_t = []
    for i in range(0,m):                                    #перебор по моделям
        curr_j = []                                         #посчитать для всех j и выбрать min
        for j in range(0,m):                                #перебор по выбору предыдущего
            curr_j[j] = d_t1[j] + beta[curr_t,j,i]          #расчет вектора всех значений, среди которых
        res[i] = np.min(curr_j)                             #ищется минимум
        k_t[i] = np.argmin(curr_j)                          #вектор k_t
    return res, k_t                                         #возвращаем рассчитанные вектора

##########################################################################################
########################Главный цикл выполнения программы#################################
##########################################################################################

u = -1                                                      #правая граница принятия решений
    
for i in range(0,3001):                                     #3000 - тест, в конце перейти на while(True)
    h_start = generate_number(h_start)                      #передача текущей модели в генератор